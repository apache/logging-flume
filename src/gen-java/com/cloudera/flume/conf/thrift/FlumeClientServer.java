/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.cloudera.flume.conf.thrift;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class FlumeClientServer {

  public interface Iface {

    public boolean heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException;

    public FlumeConfigData getConfig(String sourceId) throws TException;

    public List<String> getLogicalNodes(String physNode) throws TException;

    public void acknowledge(String ackid) throws TException;

    public boolean checkAck(String ackid) throws TException;

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public boolean heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException
    {
      send_heartbeat(logicalNode, physicalNode, host, s, timestamp);
      return recv_heartbeat();
    }

    public void send_heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("heartbeat", TMessageType.CALL, seqid_));
      heartbeat_args args = new heartbeat_args();
      args.logicalNode = logicalNode;
      args.physicalNode = physicalNode;
      args.host = host;
      args.s = s;
      args.timestamp = timestamp;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_heartbeat() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      heartbeat_result result = new heartbeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat failed: unknown result");
    }

    public FlumeConfigData getConfig(String sourceId) throws TException
    {
      send_getConfig(sourceId);
      return recv_getConfig();
    }

    public void send_getConfig(String sourceId) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, seqid_));
      getConfig_args args = new getConfig_args();
      args.sourceId = sourceId;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public FlumeConfigData recv_getConfig() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public List<String> getLogicalNodes(String physNode) throws TException
    {
      send_getLogicalNodes(physNode);
      return recv_getLogicalNodes();
    }

    public void send_getLogicalNodes(String physNode) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.CALL, seqid_));
      getLogicalNodes_args args = new getLogicalNodes_args();
      args.physNode = physNode;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getLogicalNodes() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getLogicalNodes_result result = new getLogicalNodes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getLogicalNodes failed: unknown result");
    }

    public void acknowledge(String ackid) throws TException
    {
      send_acknowledge(ackid);
      recv_acknowledge();
    }

    public void send_acknowledge(String ackid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("acknowledge", TMessageType.CALL, seqid_));
      acknowledge_args args = new acknowledge_args();
      args.ackid = ackid;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_acknowledge() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      acknowledge_result result = new acknowledge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public boolean checkAck(String ackid) throws TException
    {
      send_checkAck(ackid);
      return recv_checkAck();
    }

    public void send_checkAck(String ackid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkAck", TMessageType.CALL, seqid_));
      checkAck_args args = new checkAck_args();
      args.ackid = ackid;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_checkAck() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      checkAck_result result = new checkAck_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkAck failed: unknown result");
    }

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException
    {
      send_putReports(reports);
      recv_putReports();
    }

    public void send_putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("putReports", TMessageType.CALL, seqid_));
      putReports_args args = new putReports_args();
      args.reports = reports;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_putReports() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      putReports_result result = new putReports_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("heartbeat", new heartbeat());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("getLogicalNodes", new getLogicalNodes());
      processMap_.put("acknowledge", new acknowledge());
      processMap_.put("checkAck", new checkAck());
      processMap_.put("putReports", new putReports());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class heartbeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        heartbeat_args args = new heartbeat_args();
        args.read(iprot);
        iprot.readMessageEnd();
        heartbeat_result result = new heartbeat_result();
        result.success = iface_.heartbeat(args.logicalNode, args.physicalNode, args.host, args.s, args.timestamp);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("heartbeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConfig_args args = new getConfig_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.sourceId);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getLogicalNodes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getLogicalNodes_args args = new getLogicalNodes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getLogicalNodes_result result = new getLogicalNodes_result();
        result.success = iface_.getLogicalNodes(args.physNode);
        oprot.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class acknowledge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        acknowledge_args args = new acknowledge_args();
        args.read(iprot);
        iprot.readMessageEnd();
        acknowledge_result result = new acknowledge_result();
        iface_.acknowledge(args.ackid);
        oprot.writeMessageBegin(new TMessage("acknowledge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkAck implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkAck_args args = new checkAck_args();
        args.read(iprot);
        iprot.readMessageEnd();
        checkAck_result result = new checkAck_result();
        result.success = iface_.checkAck(args.ackid);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("checkAck", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class putReports implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        putReports_args args = new putReports_args();
        args.read(iprot);
        iprot.readMessageEnd();
        putReports_result result = new putReports_result();
        iface_.putReports(args.reports);
        oprot.writeMessageBegin(new TMessage("putReports", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class heartbeat_args implements TBase<heartbeat_args._Fields>, java.io.Serializable, Cloneable, Comparable<heartbeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartbeat_args");

    private static final TField LOGICAL_NODE_FIELD_DESC = new TField("logicalNode", TType.STRING, (short)1);
    private static final TField PHYSICAL_NODE_FIELD_DESC = new TField("physicalNode", TType.STRING, (short)4);
    private static final TField HOST_FIELD_DESC = new TField("host", TType.STRING, (short)5);
    private static final TField S_FIELD_DESC = new TField("s", TType.I32, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    public String logicalNode;
    public String physicalNode;
    public String host;
    /**
     * 
     * @see FlumeNodeState
     */
    public FlumeNodeState s;
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      LOGICAL_NODE((short)1, "logicalNode"),
      PHYSICAL_NODE((short)4, "physicalNode"),
      HOST((short)5, "host"),
      /**
       * 
       * @see FlumeNodeState
       */
      S((short)2, "s"),
      TIMESTAMP((short)3, "timestamp");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.LOGICAL_NODE, new FieldMetaData("logicalNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.PHYSICAL_NODE, new FieldMetaData("physicalNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.HOST, new FieldMetaData("host", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.S, new FieldMetaData("s", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, FlumeNodeState.class)));
      put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(heartbeat_args.class, metaDataMap);
    }

    public heartbeat_args() {
    }

    public heartbeat_args(
      String logicalNode,
      String physicalNode,
      String host,
      FlumeNodeState s,
      long timestamp)
    {
      this();
      this.logicalNode = logicalNode;
      this.physicalNode = physicalNode;
      this.host = host;
      this.s = s;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartbeat_args(heartbeat_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetLogicalNode()) {
        this.logicalNode = other.logicalNode;
      }
      if (other.isSetPhysicalNode()) {
        this.physicalNode = other.physicalNode;
      }
      if (other.isSetHost()) {
        this.host = other.host;
      }
      if (other.isSetS()) {
        this.s = other.s;
      }
      this.timestamp = other.timestamp;
    }

    public heartbeat_args deepCopy() {
      return new heartbeat_args(this);
    }

    @Deprecated
    public heartbeat_args clone() {
      return new heartbeat_args(this);
    }

    public String getLogicalNode() {
      return this.logicalNode;
    }

    public heartbeat_args setLogicalNode(String logicalNode) {
      this.logicalNode = logicalNode;
      return this;
    }

    public void unsetLogicalNode() {
      this.logicalNode = null;
    }

    /** Returns true if field logicalNode is set (has been asigned a value) and false otherwise */
    public boolean isSetLogicalNode() {
      return this.logicalNode != null;
    }

    public void setLogicalNodeIsSet(boolean value) {
      if (!value) {
        this.logicalNode = null;
      }
    }

    public String getPhysicalNode() {
      return this.physicalNode;
    }

    public heartbeat_args setPhysicalNode(String physicalNode) {
      this.physicalNode = physicalNode;
      return this;
    }

    public void unsetPhysicalNode() {
      this.physicalNode = null;
    }

    /** Returns true if field physicalNode is set (has been asigned a value) and false otherwise */
    public boolean isSetPhysicalNode() {
      return this.physicalNode != null;
    }

    public void setPhysicalNodeIsSet(boolean value) {
      if (!value) {
        this.physicalNode = null;
      }
    }

    public String getHost() {
      return this.host;
    }

    public heartbeat_args setHost(String host) {
      this.host = host;
      return this;
    }

    public void unsetHost() {
      this.host = null;
    }

    /** Returns true if field host is set (has been asigned a value) and false otherwise */
    public boolean isSetHost() {
      return this.host != null;
    }

    public void setHostIsSet(boolean value) {
      if (!value) {
        this.host = null;
      }
    }

    /**
     * 
     * @see FlumeNodeState
     */
    public FlumeNodeState getS() {
      return this.s;
    }

    /**
     * 
     * @see FlumeNodeState
     */
    public heartbeat_args setS(FlumeNodeState s) {
      this.s = s;
      return this;
    }

    public void unsetS() {
      this.s = null;
    }

    /** Returns true if field s is set (has been asigned a value) and false otherwise */
    public boolean isSetS() {
      return this.s != null;
    }

    public void setSIsSet(boolean value) {
      if (!value) {
        this.s = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public heartbeat_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case LOGICAL_NODE:
        if (value == null) {
          unsetLogicalNode();
        } else {
          setLogicalNode((String)value);
        }
        break;

      case PHYSICAL_NODE:
        if (value == null) {
          unsetPhysicalNode();
        } else {
          setPhysicalNode((String)value);
        }
        break;

      case HOST:
        if (value == null) {
          unsetHost();
        } else {
          setHost((String)value);
        }
        break;

      case S:
        if (value == null) {
          unsetS();
        } else {
          setS((FlumeNodeState)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case LOGICAL_NODE:
        return getLogicalNode();

      case PHYSICAL_NODE:
        return getPhysicalNode();

      case HOST:
        return getHost();

      case S:
        return getS();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case LOGICAL_NODE:
        return isSetLogicalNode();
      case PHYSICAL_NODE:
        return isSetPhysicalNode();
      case HOST:
        return isSetHost();
      case S:
        return isSetS();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartbeat_args)
        return this.equals((heartbeat_args)that);
      return false;
    }

    public boolean equals(heartbeat_args that) {
      if (that == null)
        return false;

      boolean this_present_logicalNode = true && this.isSetLogicalNode();
      boolean that_present_logicalNode = true && that.isSetLogicalNode();
      if (this_present_logicalNode || that_present_logicalNode) {
        if (!(this_present_logicalNode && that_present_logicalNode))
          return false;
        if (!this.logicalNode.equals(that.logicalNode))
          return false;
      }

      boolean this_present_physicalNode = true && this.isSetPhysicalNode();
      boolean that_present_physicalNode = true && that.isSetPhysicalNode();
      if (this_present_physicalNode || that_present_physicalNode) {
        if (!(this_present_physicalNode && that_present_physicalNode))
          return false;
        if (!this.physicalNode.equals(that.physicalNode))
          return false;
      }

      boolean this_present_host = true && this.isSetHost();
      boolean that_present_host = true && that.isSetHost();
      if (this_present_host || that_present_host) {
        if (!(this_present_host && that_present_host))
          return false;
        if (!this.host.equals(that.host))
          return false;
      }

      boolean this_present_s = true && this.isSetS();
      boolean that_present_s = true && that.isSetS();
      if (this_present_s || that_present_s) {
        if (!(this_present_s && that_present_s))
          return false;
        if (!this.s.equals(that.s))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(heartbeat_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      heartbeat_args typedOther = (heartbeat_args)other;

      lastComparison = Boolean.valueOf(isSetLogicalNode()).compareTo(isSetLogicalNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(logicalNode, typedOther.logicalNode);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPhysicalNode()).compareTo(isSetPhysicalNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(physicalNode, typedOther.physicalNode);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetHost()).compareTo(isSetHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(host, typedOther.host);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetS()).compareTo(isSetS());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(s, typedOther.s);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case LOGICAL_NODE:
              if (field.type == TType.STRING) {
                this.logicalNode = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case PHYSICAL_NODE:
              if (field.type == TType.STRING) {
                this.physicalNode = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case HOST:
              if (field.type == TType.STRING) {
                this.host = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case S:
              if (field.type == TType.I32) {
                this.s = FlumeNodeState.findByValue(iprot.readI32());
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIMESTAMP:
              if (field.type == TType.I64) {
                this.timestamp = iprot.readI64();
                setTimestampIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.logicalNode != null) {
        oprot.writeFieldBegin(LOGICAL_NODE_FIELD_DESC);
        oprot.writeString(this.logicalNode);
        oprot.writeFieldEnd();
      }
      if (this.s != null) {
        oprot.writeFieldBegin(S_FIELD_DESC);
        oprot.writeI32(this.s.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      if (this.physicalNode != null) {
        oprot.writeFieldBegin(PHYSICAL_NODE_FIELD_DESC);
        oprot.writeString(this.physicalNode);
        oprot.writeFieldEnd();
      }
      if (this.host != null) {
        oprot.writeFieldBegin(HOST_FIELD_DESC);
        oprot.writeString(this.host);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("heartbeat_args(");
      boolean first = true;

      sb.append("logicalNode:");
      if (this.logicalNode == null) {
        sb.append("null");
      } else {
        sb.append(this.logicalNode);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("physicalNode:");
      if (this.physicalNode == null) {
        sb.append("null");
      } else {
        sb.append(this.physicalNode);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("host:");
      if (this.host == null) {
        sb.append("null");
      } else {
        sb.append(this.host);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("s:");
      if (this.s == null) {
        sb.append("null");
      } else {
        sb.append(this.s);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartbeat_result implements TBase<heartbeat_result._Fields>, java.io.Serializable, Cloneable, Comparable<heartbeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartbeat_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(heartbeat_result.class, metaDataMap);
    }

    public heartbeat_result() {
    }

    public heartbeat_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartbeat_result(heartbeat_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public heartbeat_result deepCopy() {
      return new heartbeat_result(this);
    }

    @Deprecated
    public heartbeat_result clone() {
      return new heartbeat_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public heartbeat_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartbeat_result)
        return this.equals((heartbeat_result)that);
      return false;
    }

    public boolean equals(heartbeat_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(heartbeat_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      heartbeat_result typedOther = (heartbeat_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.BOOL) {
                this.success = iprot.readBool();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("heartbeat_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_args implements TBase<getConfig_args._Fields>, java.io.Serializable, Cloneable, Comparable<getConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");

    private static final TField SOURCE_ID_FIELD_DESC = new TField("sourceId", TType.STRING, (short)1);

    public String sourceId;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SOURCE_ID((short)1, "sourceId");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SOURCE_ID, new FieldMetaData("sourceId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
      String sourceId)
    {
      this();
      this.sourceId = sourceId;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetSourceId()) {
        this.sourceId = other.sourceId;
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    @Deprecated
    public getConfig_args clone() {
      return new getConfig_args(this);
    }

    public String getSourceId() {
      return this.sourceId;
    }

    public getConfig_args setSourceId(String sourceId) {
      this.sourceId = sourceId;
      return this;
    }

    public void unsetSourceId() {
      this.sourceId = null;
    }

    /** Returns true if field sourceId is set (has been asigned a value) and false otherwise */
    public boolean isSetSourceId() {
      return this.sourceId != null;
    }

    public void setSourceIdIsSet(boolean value) {
      if (!value) {
        this.sourceId = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SOURCE_ID:
        if (value == null) {
          unsetSourceId();
        } else {
          setSourceId((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SOURCE_ID:
        return getSourceId();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SOURCE_ID:
        return isSetSourceId();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_args)
        return this.equals((getConfig_args)that);
      return false;
    }

    public boolean equals(getConfig_args that) {
      if (that == null)
        return false;

      boolean this_present_sourceId = true && this.isSetSourceId();
      boolean that_present_sourceId = true && that.isSetSourceId();
      if (this_present_sourceId || that_present_sourceId) {
        if (!(this_present_sourceId && that_present_sourceId))
          return false;
        if (!this.sourceId.equals(that.sourceId))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_args typedOther = (getConfig_args)other;

      lastComparison = Boolean.valueOf(isSetSourceId()).compareTo(isSetSourceId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(sourceId, typedOther.sourceId);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SOURCE_ID:
              if (field.type == TType.STRING) {
                this.sourceId = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.sourceId != null) {
        oprot.writeFieldBegin(SOURCE_ID_FIELD_DESC);
        oprot.writeString(this.sourceId);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_args(");
      boolean first = true;

      sb.append("sourceId:");
      if (this.sourceId == null) {
        sb.append("null");
      } else {
        sb.append(this.sourceId);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_result implements TBase<getConfig_result._Fields>, java.io.Serializable, Cloneable, Comparable<getConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public FlumeConfigData success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, FlumeConfigData.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
      FlumeConfigData success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = new FlumeConfigData(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    @Deprecated
    public getConfig_result clone() {
      return new getConfig_result(this);
    }

    public FlumeConfigData getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(FlumeConfigData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((FlumeConfigData)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_result)
        return this.equals((getConfig_result)that);
      return false;
    }

    public boolean equals(getConfig_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_result typedOther = (getConfig_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRUCT) {
                this.success = new FlumeConfigData();
                this.success.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLogicalNodes_args implements TBase<getLogicalNodes_args._Fields>, java.io.Serializable, Cloneable, Comparable<getLogicalNodes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getLogicalNodes_args");

    private static final TField PHYS_NODE_FIELD_DESC = new TField("physNode", TType.STRING, (short)1);

    public String physNode;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PHYS_NODE((short)1, "physNode");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.PHYS_NODE, new FieldMetaData("physNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getLogicalNodes_args.class, metaDataMap);
    }

    public getLogicalNodes_args() {
    }

    public getLogicalNodes_args(
      String physNode)
    {
      this();
      this.physNode = physNode;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLogicalNodes_args(getLogicalNodes_args other) {
      if (other.isSetPhysNode()) {
        this.physNode = other.physNode;
      }
    }

    public getLogicalNodes_args deepCopy() {
      return new getLogicalNodes_args(this);
    }

    @Deprecated
    public getLogicalNodes_args clone() {
      return new getLogicalNodes_args(this);
    }

    public String getPhysNode() {
      return this.physNode;
    }

    public getLogicalNodes_args setPhysNode(String physNode) {
      this.physNode = physNode;
      return this;
    }

    public void unsetPhysNode() {
      this.physNode = null;
    }

    /** Returns true if field physNode is set (has been asigned a value) and false otherwise */
    public boolean isSetPhysNode() {
      return this.physNode != null;
    }

    public void setPhysNodeIsSet(boolean value) {
      if (!value) {
        this.physNode = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PHYS_NODE:
        if (value == null) {
          unsetPhysNode();
        } else {
          setPhysNode((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PHYS_NODE:
        return getPhysNode();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case PHYS_NODE:
        return isSetPhysNode();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLogicalNodes_args)
        return this.equals((getLogicalNodes_args)that);
      return false;
    }

    public boolean equals(getLogicalNodes_args that) {
      if (that == null)
        return false;

      boolean this_present_physNode = true && this.isSetPhysNode();
      boolean that_present_physNode = true && that.isSetPhysNode();
      if (this_present_physNode || that_present_physNode) {
        if (!(this_present_physNode && that_present_physNode))
          return false;
        if (!this.physNode.equals(that.physNode))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLogicalNodes_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLogicalNodes_args typedOther = (getLogicalNodes_args)other;

      lastComparison = Boolean.valueOf(isSetPhysNode()).compareTo(isSetPhysNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(physNode, typedOther.physNode);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case PHYS_NODE:
              if (field.type == TType.STRING) {
                this.physNode = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.physNode != null) {
        oprot.writeFieldBegin(PHYS_NODE_FIELD_DESC);
        oprot.writeString(this.physNode);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getLogicalNodes_args(");
      boolean first = true;

      sb.append("physNode:");
      if (this.physNode == null) {
        sb.append("null");
      } else {
        sb.append(this.physNode);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLogicalNodes_result implements TBase<getLogicalNodes_result._Fields>, java.io.Serializable, Cloneable, Comparable<getLogicalNodes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getLogicalNodes_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getLogicalNodes_result.class, metaDataMap);
    }

    public getLogicalNodes_result() {
    }

    public getLogicalNodes_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLogicalNodes_result(getLogicalNodes_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public getLogicalNodes_result deepCopy() {
      return new getLogicalNodes_result(this);
    }

    @Deprecated
    public getLogicalNodes_result clone() {
      return new getLogicalNodes_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getLogicalNodes_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLogicalNodes_result)
        return this.equals((getLogicalNodes_result)that);
      return false;
    }

    public boolean equals(getLogicalNodes_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLogicalNodes_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLogicalNodes_result typedOther = (getLogicalNodes_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.LIST) {
                {
                  TList _list0 = iprot.readListBegin();
                  this.success = new ArrayList<String>(_list0.size);
                  for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                  {
                    String _elem2;
                    _elem2 = iprot.readString();
                    this.success.add(_elem2);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter3 : this.success)
          {
            oprot.writeString(_iter3);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getLogicalNodes_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class acknowledge_args implements TBase<acknowledge_args._Fields>, java.io.Serializable, Cloneable, Comparable<acknowledge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("acknowledge_args");

    private static final TField ACKID_FIELD_DESC = new TField("ackid", TType.STRING, (short)1);

    public String ackid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ACKID((short)1, "ackid");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.ACKID, new FieldMetaData("ackid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(acknowledge_args.class, metaDataMap);
    }

    public acknowledge_args() {
    }

    public acknowledge_args(
      String ackid)
    {
      this();
      this.ackid = ackid;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public acknowledge_args(acknowledge_args other) {
      if (other.isSetAckid()) {
        this.ackid = other.ackid;
      }
    }

    public acknowledge_args deepCopy() {
      return new acknowledge_args(this);
    }

    @Deprecated
    public acknowledge_args clone() {
      return new acknowledge_args(this);
    }

    public String getAckid() {
      return this.ackid;
    }

    public acknowledge_args setAckid(String ackid) {
      this.ackid = ackid;
      return this;
    }

    public void unsetAckid() {
      this.ackid = null;
    }

    /** Returns true if field ackid is set (has been asigned a value) and false otherwise */
    public boolean isSetAckid() {
      return this.ackid != null;
    }

    public void setAckidIsSet(boolean value) {
      if (!value) {
        this.ackid = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ACKID:
        if (value == null) {
          unsetAckid();
        } else {
          setAckid((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ACKID:
        return getAckid();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ACKID:
        return isSetAckid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof acknowledge_args)
        return this.equals((acknowledge_args)that);
      return false;
    }

    public boolean equals(acknowledge_args that) {
      if (that == null)
        return false;

      boolean this_present_ackid = true && this.isSetAckid();
      boolean that_present_ackid = true && that.isSetAckid();
      if (this_present_ackid || that_present_ackid) {
        if (!(this_present_ackid && that_present_ackid))
          return false;
        if (!this.ackid.equals(that.ackid))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(acknowledge_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      acknowledge_args typedOther = (acknowledge_args)other;

      lastComparison = Boolean.valueOf(isSetAckid()).compareTo(isSetAckid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ackid, typedOther.ackid);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case ACKID:
              if (field.type == TType.STRING) {
                this.ackid = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ackid != null) {
        oprot.writeFieldBegin(ACKID_FIELD_DESC);
        oprot.writeString(this.ackid);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("acknowledge_args(");
      boolean first = true;

      sb.append("ackid:");
      if (this.ackid == null) {
        sb.append("null");
      } else {
        sb.append(this.ackid);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class acknowledge_result implements TBase<acknowledge_result._Fields>, java.io.Serializable, Cloneable, Comparable<acknowledge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("acknowledge_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(acknowledge_result.class, metaDataMap);
    }

    public acknowledge_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public acknowledge_result(acknowledge_result other) {
    }

    public acknowledge_result deepCopy() {
      return new acknowledge_result(this);
    }

    @Deprecated
    public acknowledge_result clone() {
      return new acknowledge_result(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof acknowledge_result)
        return this.equals((acknowledge_result)that);
      return false;
    }

    public boolean equals(acknowledge_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(acknowledge_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      acknowledge_result typedOther = (acknowledge_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("acknowledge_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkAck_args implements TBase<checkAck_args._Fields>, java.io.Serializable, Cloneable, Comparable<checkAck_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkAck_args");

    private static final TField ACKID_FIELD_DESC = new TField("ackid", TType.STRING, (short)1);

    public String ackid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ACKID((short)1, "ackid");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.ACKID, new FieldMetaData("ackid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkAck_args.class, metaDataMap);
    }

    public checkAck_args() {
    }

    public checkAck_args(
      String ackid)
    {
      this();
      this.ackid = ackid;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkAck_args(checkAck_args other) {
      if (other.isSetAckid()) {
        this.ackid = other.ackid;
      }
    }

    public checkAck_args deepCopy() {
      return new checkAck_args(this);
    }

    @Deprecated
    public checkAck_args clone() {
      return new checkAck_args(this);
    }

    public String getAckid() {
      return this.ackid;
    }

    public checkAck_args setAckid(String ackid) {
      this.ackid = ackid;
      return this;
    }

    public void unsetAckid() {
      this.ackid = null;
    }

    /** Returns true if field ackid is set (has been asigned a value) and false otherwise */
    public boolean isSetAckid() {
      return this.ackid != null;
    }

    public void setAckidIsSet(boolean value) {
      if (!value) {
        this.ackid = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ACKID:
        if (value == null) {
          unsetAckid();
        } else {
          setAckid((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ACKID:
        return getAckid();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ACKID:
        return isSetAckid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkAck_args)
        return this.equals((checkAck_args)that);
      return false;
    }

    public boolean equals(checkAck_args that) {
      if (that == null)
        return false;

      boolean this_present_ackid = true && this.isSetAckid();
      boolean that_present_ackid = true && that.isSetAckid();
      if (this_present_ackid || that_present_ackid) {
        if (!(this_present_ackid && that_present_ackid))
          return false;
        if (!this.ackid.equals(that.ackid))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkAck_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkAck_args typedOther = (checkAck_args)other;

      lastComparison = Boolean.valueOf(isSetAckid()).compareTo(isSetAckid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ackid, typedOther.ackid);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case ACKID:
              if (field.type == TType.STRING) {
                this.ackid = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ackid != null) {
        oprot.writeFieldBegin(ACKID_FIELD_DESC);
        oprot.writeString(this.ackid);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkAck_args(");
      boolean first = true;

      sb.append("ackid:");
      if (this.ackid == null) {
        sb.append("null");
      } else {
        sb.append(this.ackid);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkAck_result implements TBase<checkAck_result._Fields>, java.io.Serializable, Cloneable, Comparable<checkAck_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkAck_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkAck_result.class, metaDataMap);
    }

    public checkAck_result() {
    }

    public checkAck_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkAck_result(checkAck_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public checkAck_result deepCopy() {
      return new checkAck_result(this);
    }

    @Deprecated
    public checkAck_result clone() {
      return new checkAck_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public checkAck_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkAck_result)
        return this.equals((checkAck_result)that);
      return false;
    }

    public boolean equals(checkAck_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkAck_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkAck_result typedOther = (checkAck_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.BOOL) {
                this.success = iprot.readBool();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkAck_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class putReports_args implements TBase<putReports_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("putReports_args");

    private static final TField REPORTS_FIELD_DESC = new TField("reports", TType.MAP, (short)1);

    public Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      REPORTS((short)1, "reports");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.REPORTS, new FieldMetaData("reports", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, com.cloudera.flume.reporter.server.FlumeReport.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(putReports_args.class, metaDataMap);
    }

    public putReports_args() {
    }

    public putReports_args(
      Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports)
    {
      this();
      this.reports = reports;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putReports_args(putReports_args other) {
      if (other.isSetReports()) {
        Map<String,com.cloudera.flume.reporter.server.FlumeReport> __this__reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>();
        for (Map.Entry<String, com.cloudera.flume.reporter.server.FlumeReport> other_element : other.reports.entrySet()) {

          String other_element_key = other_element.getKey();
          com.cloudera.flume.reporter.server.FlumeReport other_element_value = other_element.getValue();

          String __this__reports_copy_key = other_element_key;

          com.cloudera.flume.reporter.server.FlumeReport __this__reports_copy_value = new com.cloudera.flume.reporter.server.FlumeReport(other_element_value);

          __this__reports.put(__this__reports_copy_key, __this__reports_copy_value);
        }
        this.reports = __this__reports;
      }
    }

    public putReports_args deepCopy() {
      return new putReports_args(this);
    }

    @Deprecated
    public putReports_args clone() {
      return new putReports_args(this);
    }

    public int getReportsSize() {
      return (this.reports == null) ? 0 : this.reports.size();
    }

    public void putToReports(String key, com.cloudera.flume.reporter.server.FlumeReport val) {
      if (this.reports == null) {
        this.reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>();
      }
      this.reports.put(key, val);
    }

    public Map<String,com.cloudera.flume.reporter.server.FlumeReport> getReports() {
      return this.reports;
    }

    public putReports_args setReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) {
      this.reports = reports;
      return this;
    }

    public void unsetReports() {
      this.reports = null;
    }

    /** Returns true if field reports is set (has been asigned a value) and false otherwise */
    public boolean isSetReports() {
      return this.reports != null;
    }

    public void setReportsIsSet(boolean value) {
      if (!value) {
        this.reports = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case REPORTS:
        if (value == null) {
          unsetReports();
        } else {
          setReports((Map<String,com.cloudera.flume.reporter.server.FlumeReport>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case REPORTS:
        return getReports();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case REPORTS:
        return isSetReports();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putReports_args)
        return this.equals((putReports_args)that);
      return false;
    }

    public boolean equals(putReports_args that) {
      if (that == null)
        return false;

      boolean this_present_reports = true && this.isSetReports();
      boolean that_present_reports = true && that.isSetReports();
      if (this_present_reports || that_present_reports) {
        if (!(this_present_reports && that_present_reports))
          return false;
        if (!this.reports.equals(that.reports))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case REPORTS:
              if (field.type == TType.MAP) {
                {
                  TMap _map4 = iprot.readMapBegin();
                  this.reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>(2*_map4.size);
                  for (int _i5 = 0; _i5 < _map4.size; ++_i5)
                  {
                    String _key6;
                    com.cloudera.flume.reporter.server.FlumeReport _val7;
                    _key6 = iprot.readString();
                    _val7 = new com.cloudera.flume.reporter.server.FlumeReport();
                    _val7.read(iprot);
                    this.reports.put(_key6, _val7);
                  }
                  iprot.readMapEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.reports != null) {
        oprot.writeFieldBegin(REPORTS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.reports.size()));
          for (Map.Entry<String, com.cloudera.flume.reporter.server.FlumeReport> _iter8 : this.reports.entrySet())
          {
            oprot.writeString(_iter8.getKey());
            _iter8.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putReports_args(");
      boolean first = true;

      sb.append("reports:");
      if (this.reports == null) {
        sb.append("null");
      } else {
        sb.append(this.reports);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class putReports_result implements TBase<putReports_result._Fields>, java.io.Serializable, Cloneable, Comparable<putReports_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("putReports_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(putReports_result.class, metaDataMap);
    }

    public putReports_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putReports_result(putReports_result other) {
    }

    public putReports_result deepCopy() {
      return new putReports_result(this);
    }

    @Deprecated
    public putReports_result clone() {
      return new putReports_result(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putReports_result)
        return this.equals((putReports_result)that);
      return false;
    }

    public boolean equals(putReports_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(putReports_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      putReports_result typedOther = (putReports_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putReports_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
